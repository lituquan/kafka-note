### pull
    拉模式，避免由Broker控制消费速率

### 消费者组
    groupid相同为同一组
    消费者组内每个消费者负责消费不同分区的数据，一个分区只能由一个组内消费者消费。
    消费者组之间互不影响。所有的消费者都属于某个消费者组，即消费者组是逻辑上的一个订阅者。
#### 独立消费者

    注意：
        在消费者 API 代码中必须配置消费者组 id。命令行启动消费者不填写消费者组 id 会被自动填写随机的消费者组 id
#### 消费者组
    
    分区的分配以及再平衡
        1、一个consumer group中有多个consumer组成，一个 topic有多个partition组成，现在的问题是，到底由哪个consumer来消费哪个partition的数据。

        2、Kafka有四种主流的分区分配策略： Range、RoundRobin、Sticky、CooperativeSticky。
        可以通过配置参数partition.assignment.strategy，修改分区的分配策略。默认策略是Range + CooperativeSticky。Kafka可以同时使用多个分区分配策略。
##### range
    Range 是对每个 topic 而言的。
    (1)过程
        首先对同一个 topic 里面的分区按照序号进行排序，并对消费者按照字母顺序进行排序。
        假如现在有 7 个分区，3 个消费者，排序后的分区将会是0,1,2,3,4,5,6；消费者排序完之后将会是C0,C1,C2。例如，7/3 = 2 余 1 ，除不尽，那么 消费者 C0 便会多消费 1 个分区。 8/3=2余2，除不尽，那么C0和C1分别多消费一个。

        通过 partitions数/consumer数 来决定每个消费者应该消费几个分区。如果除不尽，那么前面几个消费者将会多消费 1 个分区。分区分配策略之Range
    注意：
        如果只是针对 1 个 topic 而言，C0消费者多消费1个分区影响不是很大。但是如果有 N 多个 topic，那么针对每个 topic，消费者 C0都将多消费 1 个分区，topic越多，C0消费的分区会比其他消费者明显多消费 N 个分区。容易产生数据倾斜！
        
        分区数可以增加，但是不能减少。

    ()2均衡
        5.4.1.2.3 Range 分区分配再平衡案例
        （1）消费者挂掉后，消费者组需要按照超时时间 45s 来判断它是否退出，所以需要等待，时间到了 45s 后，判断它真的退出就会把任务分配给其他 broker 执行。

        （2）再次重新发送消息观看结果（45s 以后）。
        1 号消费者：消费到 0、1、2、3 号分区数据。
        2 号消费者：消费到 4、5、6 号分区数据。
        说明：消费者 0 已经被踢出消费者组，所以重新按照 range 方式分配。

#### RoundRobin 

### 参数

